1a) I would say that this is a bad hashing algorithm for 2 reasons. The first is that there is the possibility of many collisions.
If the user enters a lot of names that start with the same letter, they would all hash to the same bucket. Thus, that bucket would
grow and hash table operations (searching, inserting, etc.) would be slower. The second reason is that this algorithm does not
distribute values over the entirety of the hash table and a lot of extra space is being allocated but never used. Since the
hash is equal to the ASCII value of the first letter mod 2048, the hash values would only be in the range [97, 122]. Therefore,
about 9/10 of the hash table would never be used.

1b) One problem with this hashing algorithm is it has a high probability of collisions. Consider any number that has 0 as one 
of its digits. In the range [0, 999], this would be 0, 10, 20, ..., 90, 100-109, 110, ..., 190, 200-209, etc. In total, 
19*9 + 10 = 181 of the possible 1000 values will hash to 0 because the product of the digits of a number that contains 0 as
a digit is 0 and 0 mod 1000 is 0. Thus, nearly 20% of the possible inputs hash to the same bucket, that is there is a 20% 
collision rate. A better hash function, which would use the entire table and have a 0% collision rate would be to simply
have the hash(key) = key. Since there are 1000 buckets and the possible values are [0, 999], the table could accomodate
all the possible inputs at once. Furthermore, this would guarantee O(1) operations.

1c) This algorithm, while it may seem to distribute the inputs, would not work for a hash table because of the random factor.
Suppose one inserts 31,100 into the hash table. Suppose that the random integer is 9, therefore the hash of 31,100 is 
(31,100 * 9) % 1000 = 900. The table places 31,100 in the bucket at index=900. Now, suppose the user wishes to see if
31,1000 is contained in the table. There is no guarantee that the random number that is generated by passing 31,100 to the 
hash function will be 9 again. Thus, the table would not know that 31,100 is already in the table. In summary, if a key is
passed to a hash function, the function must promise to return the same hash value any time that key is passed as input.

